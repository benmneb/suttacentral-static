name: Build & Preview Release

on:
  push:
    tags:
      - 'v*.*.*'
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]
  workflow_dispatch:
  schedule:
    - cron: '0 0 1 * *' # Monthly on 1st at midnight UTC

permissions:
  contents: write
  pull-requests: write

jobs:
  check-tag:
    name: Check Tag Branch
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    outputs:
      on-main: ${{ steps.check.outputs.on-main }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if tag is on main branch
        id: check
        run: |
          if git branch -r --contains ${{ github.ref }} | grep -q 'origin/main'; then
            echo "on-main=true" >> $GITHUB_OUTPUT
            echo "âœ“ Tag ${{ github.ref_name }} is on main branch"
          else
            echo "on-main=false" >> $GITHUB_OUTPUT
            echo "âŠ˜ Tag ${{ github.ref_name }} is NOT on main branch - skipping production release"
          fi

  release-draft:
    name: Create Draft Release
    runs-on: ubuntu-latest
    needs: check-tag
    if: needs.check-tag.outputs.on-main == 'true'
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      preview_url: ${{ steps.vercel_deploy.outputs.preview_url }}
      date: ${{ steps.date.outputs.date }}
      tag_message: ${{ steps.tag_message.outputs.message }}
      html_count: ${{ steps.size.outputs.html_count }}
      total_count: ${{ steps.size.outputs.total_count }}
      archive_name: ${{ steps.archive.outputs.archive_name }}
      archive_size: ${{ steps.size.outputs.size }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Fetch tag annotations
        run: git fetch --tags --force

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24.3.0'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Build site
        run: pnpm run predeploy

      - name: Get current version
        id: version
        run: |
          VERSION=$(git describe --tags --abbrev=0 | sed 's/^v//')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$(git describe --tags --abbrev=0)" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Generate datestamp
        id: date
        run: |
          DATE=$(date +%Y%m%d)
          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "Datestamp: $DATE"

      - name: Get tag message
        id: tag_message
        run: |
          # Get the tag annotation message (not commit message)
          # git cat-file gets the raw tag object, then we skip headers until blank line
          TAG_MESSAGE=$(git cat-file tag ${{ steps.version.outputs.tag }} | sed '1,/^$/d')
          if [ -z "$TAG_MESSAGE" ]; then
            TAG_MESSAGE="Version ${{ steps.version.outputs.tag }}"
          fi
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$TAG_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create archive
        id: archive
        run: |
          ARCHIVE_NAME="scx_archive-${{ steps.version.outputs.version }}.tar.gz"
          echo "Creating archive: $ARCHIVE_NAME"
          mkdir -p .dist
          tar -czf .dist/$ARCHIVE_NAME _site
          echo "archive_name=$ARCHIVE_NAME" >> $GITHUB_OUTPUT
          echo "archive_path=.dist/$ARCHIVE_NAME" >> $GITHUB_OUTPUT

      - name: Get archive size and file count
        id: size
        run: |
          SIZE=$(du -h .dist/${{ steps.archive.outputs.archive_name }} | cut -f1)
          echo "size=$SIZE" >> $GITHUB_OUTPUT
          echo "Archive size: $SIZE"

          HTML_COUNT=$(find _site -type f -name "*.html" | wc -l | tr -d ' ')
          TOTAL_COUNT=$(find _site -type f | wc -l | tr -d ' ')
          echo "html_count=$HTML_COUNT" >> $GITHUB_OUTPUT
          echo "total_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT
          echo "HTML files: $HTML_COUNT"
          echo "Total files: $TOTAL_COUNT"

      - name: Deploy to Vercel Preview
        id: vercel_deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          OUTPUT=$(npx vercel deploy --archive=tgz --cwd=_site --token="$VERCEL_TOKEN" 2>&1 | tee /dev/stderr)
          URL=$(echo "$OUTPUT" | grep -o 'https://[^ ]*vercel\.app[^ ]*' | head -1)
          echo "preview_url=$URL" >> $GITHUB_OUTPUT
          echo "Preview URL: $URL"

      - name: Upload site artifact for Tauri builds
        uses: actions/upload-artifact@v4
        with:
          name: site-build
          path: _site
          retention-days: 1

      - name: Create draft release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: v${{ steps.version.outputs.version }}
          draft: true
          body: |
            ${{ steps.tag_message.outputs.message }}

            ---

            **Preview Deployment:** ${{ steps.vercel_deploy.outputs.preview_url }}

            > â³ **Desktop app builds in progress.** Please wait for all builds to complete before publishing.

            **Build Info:**
            - Date: ${{ steps.date.outputs.date }}
            - Trigger: Tag push to main
            - Version: ${{ steps.version.outputs.version }}
            - Files: ${{ steps.size.outputs.html_count }} HTML files (${{ steps.size.outputs.total_count }} total)
          files: .dist/${{ steps.archive.outputs.archive_name }}
          token: ${{ secrets.GITHUB_TOKEN }}

  build-tauri:
    name: Build Tauri (${{ matrix.name }})
    needs: release-draft
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            args: '--target aarch64-apple-darwin'
            name: 'macOS ARM64'
            rust_target: 'aarch64-apple-darwin'
          - platform: macos-latest
            args: '--target x86_64-apple-darwin'
            name: 'macOS Intel'
            rust_target: 'x86_64-apple-darwin'
          - platform: ubuntu-22.04
            args: ''
            name: 'Linux'
            rust_target: ''
          - platform: windows-latest
            args: ''
            name: 'Windows'
            rust_target: ''
    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download site artifact
        uses: actions/download-artifact@v4
        with:
          name: site-build
          path: _site

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24.3.0'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './tauri -> target'

      - name: Update Tauri version
        shell: bash
        run: |
          VERSION="${{ needs.release-draft.outputs.version }}"
          if command -v jq &> /dev/null; then
            jq --arg v "$VERSION" '.version = $v' tauri/tauri.conf.json > tmp.json && mv tmp.json tauri/tauri.conf.json
          else
            # Windows fallback using Node.js
            node -e "const fs=require('fs'); const c=JSON.parse(fs.readFileSync('tauri/tauri.conf.json')); c.version='$VERSION'; fs.writeFileSync('tauri/tauri.conf.json', JSON.stringify(c,null,2)+'\n');"
          fi
          echo "Updated tauri.conf.json version to $VERSION"

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: ./tauri
          tauriScript: pnpm tauri
          args: ${{ matrix.args }}

      - name: Rename artifacts
        shell: bash
        run: |
          VERSION="${{ needs.release-draft.outputs.version }}"
          mkdir -p artifacts

          # macOS
          shopt -s nullglob
          for f in tauri/target/*/release/bundle/dmg/*.dmg; do
            if [[ "$f" == *"aarch64"* ]]; then ARCH="aarch64"; else ARCH="x64"; fi
            cp "$f" "artifacts/scx_app-${VERSION}-macos_${ARCH}.dmg"
          done

          # Windows
          for f in tauri/target/release/bundle/nsis/*.exe; do
            cp "$f" "artifacts/scx_app-${VERSION}-windows_x64.exe"
          done

          # Linux
          for f in tauri/target/release/bundle/appimage/*.AppImage; do
            cp "$f" "artifacts/scx_app-${VERSION}-linux_amd64.AppImage"
          done
          shopt -u nullglob

          echo "Artifacts:"
          ls -la artifacts/ || echo "No artifacts found"

      - name: Upload to release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.release-draft.outputs.tag }}
          files: artifacts/*
          token: ${{ secrets.GITHUB_TOKEN }}

  sign-release:
    name: Sign Release Artifacts
    needs: [release-draft, build-tauri]
    runs-on: ubuntu-latest
    outputs:
      signed: ${{ steps.sign.outputs.signed }}
    steps:
      - name: Download release artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p artifacts
          gh release download "${{ needs.release-draft.outputs.tag }}" \
            --repo "${{ github.repository }}" \
            --pattern "scx_app-*" \
            --dir artifacts
          echo "Downloaded artifacts:"
          ls -la artifacts/

      - name: Generate SHA256 checksums
        run: |
          cd artifacts
          sha256sum scx_app-* > SHA256SUMS.txt
          echo "Generated checksums:"
          cat SHA256SUMS.txt

      - name: Sign checksums with PGP
        id: sign
        env:
          PGP_PRIVATE_KEY: ${{ secrets.PGP_PRIVATE_KEY }}
          PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
        run: |
          if [ -n "$PGP_PRIVATE_KEY" ]; then
            echo "$PGP_PRIVATE_KEY" | gpg --batch --import
            cd artifacts
            echo "$PGP_PASSPHRASE" | gpg --batch --yes --pinentry-mode loopback \
              --passphrase-fd 0 --armor --detach-sign SHA256SUMS.txt
            echo "Created signature: SHA256SUMS.txt.asc"
            echo "signed=true" >> $GITHUB_OUTPUT
          else
            echo "PGP_PRIVATE_KEY not configured, skipping signing"
            echo "signed=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload checksums and signature
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.release-draft.outputs.tag }}
          files: |
            artifacts/SHA256SUMS.txt
            artifacts/SHA256SUMS.txt.asc
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  finalize-release:
    name: Finalize Release
    needs: [release-draft, build-tauri, sign-release]
    runs-on: ubuntu-latest
    steps:
      - name: Update release body
        uses: actions/github-script@v7
        with:
          script: |
            const signed = '${{ needs.sign-release.outputs.signed }}' === 'true';
            const tagMessage = `${{ needs.release-draft.outputs.tag_message }}`;
            const gpgSection = signed ? `

            Import my public key, one time (same key used to sign all commits to this repo)
            \`\`\`bash
            gpg --keyserver keys.openpgp.org --recv-keys AECABD60A4CB5BE900864AF2C8DAB4CE409C4AB8
            \`\`\`

            Verify signature
            \`\`\`bash
            gpg --verify SHA256SUMS.txt.asc SHA256SUMS.txt
            \`\`\`` : '';
            const body = `${tagMessage}

            <details>
            <summary><strong>Verify Asset Downloads</strong></summary>

            Verify checksum matches
            \`\`\`bash
            sha256sum -c --ignore-missing SHA256SUMS.txt
            \`\`\`${gpgSection}
            </details>

            ---

            **Preview Deployment:** ${{ needs.release-draft.outputs.preview_url }}

            **Desktop Apps:** âœ… All platforms ready (macOS ARM64, macOS Intel, Windows, Linux)

            **Build Info:**
            - Date: ${{ needs.release-draft.outputs.date }}
            - Trigger: Tag push to main
            - Version: ${{ needs.release-draft.outputs.version }}
            - Files: ${{ needs.release-draft.outputs.html_count }} HTML files (${{ needs.release-draft.outputs.total_count }} total)

            **Next Steps:**
            1. Review the preview deployment above
            2. If satisfied, edit this release body and click "Publish release" to deploy to production
            3. Publishing will automatically:
               - Deploy the exact same build to Vercel production
               - Upload assets to Codeberg releases`;

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.release-draft.outputs.release_id }},
              body: body
            });

            console.log('âœ“ Release body updated - all desktop builds complete');

  pr-preview:
    name: Pull Request Preview
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24.3.0'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Build site
        run: pnpm run predeploy

      - name: Create archive for preview
        env:
          CI: true
        run: pnpm run release:dry

      - name: Deploy to Vercel Preview
        id: vercel_preview
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          OUTPUT=$(npx vercel deploy --archive=tgz --cwd=_site --token="$VERCEL_TOKEN" 2>&1 | tee /dev/stderr)
          URL=$(echo "$OUTPUT" | grep -o 'https://[^ ]*vercel\.app[^ ]*' | head -1)
          echo "preview_url=$URL" >> $GITHUB_OUTPUT
          echo "Preview URL: $URL"

      - name: Comment PR with preview URL
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## Preview Deployment\n\nðŸš€ Preview is ready: ${{ steps.vercel_preview.outputs.preview_url }}'
            })

  content-refresh:
    name: Content Refresh Build
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      version: ${{ steps.version.outputs.version }}
      preview_tag: ${{ steps.preview_tag.outputs.tag }}
      date: ${{ steps.date.outputs.date }}
      preview_url: ${{ steps.vercel_deploy.outputs.preview_url }}
      html_count: ${{ steps.size.outputs.html_count }}
      total_count: ${{ steps.size.outputs.total_count }}
      archive_name: ${{ steps.archive.outputs.archive_name }}
      archive_size: ${{ steps.size.outputs.size }}
      trigger: ${{ github.event_name == 'schedule' && 'Monthly scheduled build' || 'Manual trigger' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24.3.0'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Build site
        run: pnpm run predeploy

      - name: Get current version
        id: version
        run: |
          # Get the latest tag and extract only the base version (remove any preview suffixes)
          LATEST_TAG=$(git describe --tags --abbrev=0)
          # Extract base version (e.g., "1.3.0" from "v1.3.0-content-refresh-20251218-110205")
          BASE_VERSION=$(echo "$LATEST_TAG" | sed 's/^v//' | sed 's/-content-refresh-.*$//')
          echo "version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "Base version: $BASE_VERSION"

      - name: Generate datestamp
        id: date
        run: |
          DATE=$(date +%Y%m%d)
          echo "date=$DATE" >> $GITHUB_OUTPUT
          echo "Datestamp: $DATE"

      - name: Generate timestamp
        id: timestamp
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "Timestamp: $TIMESTAMP"

      - name: Create preview tag
        id: preview_tag
        run: |
          TAG="${{ steps.version.outputs.tag }}-content-refresh-${{ steps.timestamp.outputs.timestamp }}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Preview tag: $TAG"

      - name: Push preview tag to all remotes
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO: ${{ secrets.CODEBERG_REPO }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create the tag
          git tag ${{ steps.preview_tag.outputs.tag }}

          # Push to GitHub (origin)
          git push origin ${{ steps.preview_tag.outputs.tag }}

          # Push to Codeberg (if configured)
          if [ -n "$CODEBERG_TOKEN" ] && [ -n "$CODEBERG_REPO" ]; then
            git push https://oauth2:${CODEBERG_TOKEN}@codeberg.org/${CODEBERG_REPO} ${{ steps.preview_tag.outputs.tag }} || echo "âŠ˜ Codeberg push failed"
          else
            echo "âŠ˜ Codeberg not configured, skipping tag push"
          fi

      - name: Create archive
        id: archive
        env:
          CI: true
        run: |
          ARCHIVE_NAME="scx_archive-${{ steps.version.outputs.version }}-content-refresh-${{ steps.date.outputs.date }}.tar.gz"
          echo "Creating archive: $ARCHIVE_NAME"
          mkdir -p .dist
          tar -czf .dist/$ARCHIVE_NAME _site
          echo "archive_name=$ARCHIVE_NAME" >> $GITHUB_OUTPUT
          echo "archive_path=.dist/$ARCHIVE_NAME" >> $GITHUB_OUTPUT

      - name: Deploy to Vercel Preview
        id: vercel_deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          OUTPUT=$(npx vercel deploy --archive=tgz --cwd=_site --token="$VERCEL_TOKEN" 2>&1 | tee /dev/stderr)
          URL=$(echo "$OUTPUT" | grep -o 'https://[^ ]*vercel\.app[^ ]*' | head -1)
          echo "preview_url=$URL" >> $GITHUB_OUTPUT
          echo "Preview URL: $URL"

      - name: Get archive size and file count
        id: size
        run: |
          SIZE=$(du -h .dist/${{ steps.archive.outputs.archive_name }} | cut -f1)
          echo "size=$SIZE" >> $GITHUB_OUTPUT
          echo "Archive size: $SIZE"

          HTML_COUNT=$(find _site -type f -name "*.html" | wc -l | tr -d ' ')
          TOTAL_COUNT=$(find _site -type f | wc -l | tr -d ' ')
          echo "html_count=$HTML_COUNT" >> $GITHUB_OUTPUT
          echo "total_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT
          echo "HTML files: $HTML_COUNT"
          echo "Total files: $TOTAL_COUNT"

      - name: Upload site artifact for Tauri builds
        uses: actions/upload-artifact@v4
        with:
          name: site-build-content-refresh
          path: _site
          retention-days: 1

      - name: Create pre-release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.preview_tag.outputs.tag }}
          name: v${{ steps.version.outputs.version }} - Content Refresh (${{ steps.date.outputs.date }})
          draft: false
          prerelease: true
          body: |
            Fresh content fetched from SuttaCentral APIs

            ---

            **Preview Deployment:** ${{ steps.vercel_deploy.outputs.preview_url }}

            > â³ **Desktop app builds in progress.** Please wait for all builds to complete before publishing.

            **Build Info:**
            - Date: ${{ steps.date.outputs.date }}
            - Trigger: ${{ github.event_name == 'schedule' && 'Monthly scheduled build' || 'Manual trigger' }}
            - Version: ${{ steps.version.outputs.version }}
            - Preview Tag: ${{ steps.preview_tag.outputs.tag }}
            - Files: ${{ steps.size.outputs.html_count }} HTML files (${{ steps.size.outputs.total_count }} total)
          files: .dist/${{ steps.archive.outputs.archive_name }}
          token: ${{ secrets.GITHUB_TOKEN }}

  build-tauri-content-refresh:
    name: Build Tauri Content Refresh (${{ matrix.name }})
    needs: content-refresh
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            args: '--target aarch64-apple-darwin'
            name: 'macOS ARM64'
            rust_target: 'aarch64-apple-darwin'
          - platform: macos-latest
            args: '--target x86_64-apple-darwin'
            name: 'macOS Intel'
            rust_target: 'x86_64-apple-darwin'
          - platform: ubuntu-22.04
            args: ''
            name: 'Linux'
            rust_target: ''
          - platform: windows-latest
            args: ''
            name: 'Windows'
            rust_target: ''
    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download site artifact
        uses: actions/download-artifact@v4
        with:
          name: site-build-content-refresh
          path: _site

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24.3.0'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './tauri -> target'

      - name: Update Tauri version
        shell: bash
        run: |
          VERSION="${{ needs.content-refresh.outputs.version }}-content-refresh-${{ needs.content-refresh.outputs.date }}"
          if command -v jq &> /dev/null; then
            jq --arg v "$VERSION" '.version = $v' tauri/tauri.conf.json > tmp.json && mv tmp.json tauri/tauri.conf.json
          else
            # Windows fallback using Node.js
            node -e "const fs=require('fs'); const c=JSON.parse(fs.readFileSync('tauri/tauri.conf.json')); c.version='$VERSION'; fs.writeFileSync('tauri/tauri.conf.json', JSON.stringify(c,null,2)+'\n');"
          fi
          echo "Updated tauri.conf.json version to $VERSION"

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: ./tauri
          tauriScript: pnpm tauri
          args: ${{ matrix.args }}

      - name: Rename artifacts
        shell: bash
        run: |
          VERSION="${{ needs.content-refresh.outputs.version }}-content-refresh-${{ needs.content-refresh.outputs.date }}"
          mkdir -p artifacts

          # macOS
          shopt -s nullglob
          for f in tauri/target/*/release/bundle/dmg/*.dmg; do
            if [[ "$f" == *"aarch64"* ]]; then ARCH="aarch64"; else ARCH="x64"; fi
            cp "$f" "artifacts/scx_app-${VERSION}-macos_${ARCH}.dmg"
          done

          # Windows
          for f in tauri/target/release/bundle/nsis/*.exe; do
            cp "$f" "artifacts/scx_app-${VERSION}-windows_x64.exe"
          done

          # Linux
          for f in tauri/target/release/bundle/appimage/*.AppImage; do
            cp "$f" "artifacts/scx_app-${VERSION}-linux_amd64.AppImage"
          done
          shopt -u nullglob

          echo "Artifacts:"
          ls -la artifacts/ || echo "No artifacts found"

      - name: Upload to release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.content-refresh.outputs.preview_tag }}
          files: artifacts/*
          token: ${{ secrets.GITHUB_TOKEN }}

  sign-release-content-refresh:
    name: Sign Content Refresh Artifacts
    needs: [content-refresh, build-tauri-content-refresh]
    runs-on: ubuntu-latest
    outputs:
      signed: ${{ steps.sign.outputs.signed }}
    steps:
      - name: Download release artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p artifacts
          gh release download "${{ needs.content-refresh.outputs.preview_tag }}" \
            --repo "${{ github.repository }}" \
            --pattern "scx_app-*" \
            --dir artifacts
          echo "Downloaded artifacts:"
          ls -la artifacts/

      - name: Generate SHA256 checksums
        run: |
          cd artifacts
          sha256sum scx_app-* > SHA256SUMS.txt
          echo "Generated checksums:"
          cat SHA256SUMS.txt

      - name: Sign checksums with PGP
        id: sign
        env:
          PGP_PRIVATE_KEY: ${{ secrets.PGP_PRIVATE_KEY }}
          PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
        run: |
          if [ -n "$PGP_PRIVATE_KEY" ]; then
            echo "$PGP_PRIVATE_KEY" | gpg --batch --import
            cd artifacts
            echo "$PGP_PASSPHRASE" | gpg --batch --yes --pinentry-mode loopback \
              --passphrase-fd 0 --armor --detach-sign SHA256SUMS.txt
            echo "Created signature: SHA256SUMS.txt.asc"
            echo "signed=true" >> $GITHUB_OUTPUT
          else
            echo "PGP_PRIVATE_KEY not configured, skipping signing"
            echo "signed=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload checksums and signature
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.content-refresh.outputs.preview_tag }}
          files: |
            artifacts/SHA256SUMS.txt
            artifacts/SHA256SUMS.txt.asc
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  finalize-release-content-refresh:
    name: Finalize Content Refresh Release
    needs:
      [
        content-refresh,
        build-tauri-content-refresh,
        sign-release-content-refresh,
      ]
    runs-on: ubuntu-latest
    steps:
      - name: Update release body
        uses: actions/github-script@v7
        with:
          script: |
            const signed = '${{ needs.sign-release-content-refresh.outputs.signed }}' === 'true';
            const gpgSection = signed ? `

            Import my public key, one time (same key used to sign all commits to this repo)
            \`\`\`bash
            gpg --keyserver keys.openpgp.org --recv-keys AECABD60A4CB5BE900864AF2C8DAB4CE409C4AB8
            \`\`\`

            Verify signature
            \`\`\`bash
            gpg --verify SHA256SUMS.txt.asc SHA256SUMS.txt
            \`\`\`` : '';
            const body = `Fresh content fetched from SuttaCentral APIs

            <details>
            <summary><strong>Verify Asset Downloads</strong></summary>

            Verify checksum matches
            \`\`\`bash
            sha256sum -c --ignore-missing SHA256SUMS.txt
            \`\`\`${gpgSection}
            </details>

            ---

            **Preview Deployment:** ${{ needs.content-refresh.outputs.preview_url }}

            **Desktop Apps:** âœ… All platforms ready (macOS ARM64, macOS Intel, Windows, Linux)

            **Build Info:**
            - Date: ${{ needs.content-refresh.outputs.date }}
            - Trigger: ${{ needs.content-refresh.outputs.trigger }}
            - Version: ${{ needs.content-refresh.outputs.version }}
            - Preview Tag: ${{ needs.content-refresh.outputs.preview_tag }}
            - Files: ${{ needs.content-refresh.outputs.html_count }} HTML files (${{ needs.content-refresh.outputs.total_count }} total)

            **Next Steps:**
            1. Review the preview deployment above
            2. If satisfied, edit this release body and uncheck "Set as a pre-release" to promote to production
            3. Publishing will automatically:
               - Deploy the exact same build to Vercel production
               - Upload assets to Codeberg releases
               - Clean up the preview tag from all remotes
            4. Deleting will automatically:
               - Clean up the preview tag from all remotes`;

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.content-refresh.outputs.release_id }},
              body: body
            });

            console.log('âœ“ Release body updated - all desktop builds complete');
